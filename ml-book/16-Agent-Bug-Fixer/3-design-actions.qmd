---
title: "16.3 赋予Agent“行动力”：定义工具箱与求助LLM"
---

## Agent的"双手"：定义工具 (Actions)

**【AI导演】**

> **场景**: 我们已经为Agent创造了一个世界 (`BuggyProject`)。现在，我们需要赋予它改变这个世界的能力。在Agent的语境中，这种能力不是通过直接操纵实现的，而是通过**调用工具 (Tools)** 来完成的。
>
> 就像一个修理工有他的工具箱（扳手、螺丝刀、电焊机）一样，我们的Bug修复Agent也需要一个它的**数字工具箱**。这个工具箱，在强化学习的框架下，就是它的**动作空间 (Action Space)**。
>
> **你的任务**: 与你的AI伙伴一起，用Python函数的形式，为我们的Agent定义一套核心的工具。最关键的是，你将学习如何**将强大的LLM封装成Agent可以调用的一个普通工具**。



### 指令剧本：为Agent打造工具箱

一个想要修复Bug的Agent，至少需要具备哪些基本能力？

1.  **看一看**: 它得能读取文件内容，了解当前代码是什么样的。
2.  **改一改**: 它得能修改文件，应用它认为正确的修复方案。
3.  **想一想**: 当它自己没头绪时，它得能"求助大脑"，也就是向一个更强大的智能（LLM）寻求建议。

现在，让我们把这些能力转化为具体的Python函数。

#### **第一步：定义基础文件操作工具**

**【给AI的提示词】**

> 我们来定义Agent的基础工具。请帮我编写两个Python函数：
>
> 1.  `read_file(project, filename)`:
>     *   接收一个 `BuggyProject` 实例和 `filename` 作为输入。
>     *   它应该从 `project.files` 字典中读取并返回对应文件的内容。
>     *   如果文件不存在，应该返回一个错误信息字符串。
>
> 2.  `write_file(project, filename, content)`:
>     *   接收 `project` 实例、`filename` 和新的 `content` 作为输入。
>     *   它会更新 `project.files` 字典中对应文件的内容。
>     *   这个函数不需要返回值。



#### **第二步：封装核心工具——向LLM求助**

这是本章最核心的理念转变：**LLM不再是我们的直接交互对象，而是Agent工具箱里的一个工具**。Agent将自主决定**何时**以及**如何**使用这个强大的"大脑"。

**【给AI的提示词】**

> 现在，请帮我设计最重要的工具：`ask_llm_for_suggestion`。
>
> 这个函数是Agent的"思考"工具。它接收 `code_content` (一个字符串，包含有问题的代码) 和 `error_message` (运行测试时得到的错误) 作为输入。
>
> 在函数内部，它需要：
> 1.  **设计一个精巧的Prompt**: 这是关键！我们需要创建一个Prompt模板，它能清晰地向LLM描述问题，并要求它以特定的格式返回解决方案。
> 2.  **调用LLM API (模拟)**: 将`code_content`和`error_message`填入模板，然后调用一个LLM。
> 3.  **返回LLM的建议**: 返回LLM生成的、可用于修复代码的字符串。
>
> **下面是一个优秀的Prompt模板设计，请将它用在你的函数里：**
>
> ```python
> prompt_template = """
> You are an expert Python programmer tasked with fixing a bug.
>
> Here is the current code from the file:
> ```python
> {code}
> ```
>
> When running the tests, the following error occurred:
> ```
> {error}
> ```
>
> Your task is to analyze the code and the error, and provide a fixed version of the code.
>
> **IMPORTANT**: You must only output the complete, corrected Python code for the file. Do not include any explanation, comments, or any text other than the code itself.
> """
> ```
>
> **注意**: 为了简化项目，我们暂时**不需要真正调用一个付费的LLM API**。请在函数中用一个**模拟的返回**来代替真实的API调用。例如，让它直接返回正确的代码：`return "def add(a, b):\n    return a + b\n"`。这能让我们在不依赖外部服务的情况下，完整地测试Agent的逻辑。


<details>
<summary>点击查看AI可能的输出 (包含模拟的LLM调用)</summary>

```python
# ... read_file 和 write_file 函数 ...

def ask_llm_for_suggestion(code_content, error_message):
    """
    (模拟)向LLM求助，获取代码修复建议。
    在真实项目中，这里会包含API调用、错误处理等。
    """
    prompt_template = """
    You are an expert Python programmer tasked with fixing a bug.

    Here is the current code from the file:
    ```python
    {code}
    ```

    When running the tests, the following error occurred:
    ```
    {error}
    ```

    Your task is to analyze the code and the error, and provide a fixed version of the code.

    **IMPORTANT**: You must only output the complete, corrected Python code for the file. Do not include any explanation, comments, or any text other than the code itself.
    """
    
    # 1. 构建Prompt (真实场景)
    # prompt = prompt_template.format(code=code_content, error=error_message)
    
    # 2. 调用LLM API (真实场景)
    # response = call_openai_api(prompt) 
    # fixed_code = response.choices[0].text.strip()
    
    # 3. **模拟返回** (当前项目)
    # 我们知道正确答案，所以直接返回它，以测试Agent的逻辑
    print("---LLM TOOL CALLED---")
    print(f"Simulating LLM call with code:\n{code_content}\nand error:\n{error_message}")
    fixed_code = "def add(a, b):\n    return a + b\n"
    print(f"LLM suggested fix:\n{fixed_code}")
    print("---LLM TOOL END---")
    
    return fixed_code

```
</details>



> **学习者笔记**:
>
> 我们已经成功为Agent定义了它的**动作空间 (Action Space)**。
>
> -   `read_file('main.py')`
> -   `write_file('main.py', new_content)`
> -   `ask_llm_for_suggestion(current_code, error)`
>
> Agent的**策略 (Policy)**，就是要学习在各种不同的状态下（比如不同的错误信息），应该**按什么顺序、以什么参数**来调用这些工具。
>
> *   是应该先读文件，再求助LLM？
> *   还是拿到LLM的建议后，就直接写入文件？
> *   如果写入后测试仍然失败，下一步该怎么办？是再次求助LLM，还是尝试自己做一些微调？
>
> 这些复杂的决策链，就是我们的Agent需要学习的东西。在下一节，我们将为它设计"价值观"——奖励函数，来引导它做出正确的决策。 