---
title: "16.2 设计Agent的“世界观”：构建沙盒环境"
---

## 为你的Agent创造一个"代码宇宙"

**【AI导演】**

> **场景**: 每个智能体都需要一个**环境 (Environment)** 来与之交互。对于我们的Bug修复Agent，它的环境就是一个代码项目。
>
> 直接让Agent操作你电脑上的真实文件系统是极其危险的！我们必须为它创造一个**沙盒 (Sandbox)** 环境——一个完全在内存中模拟的、与外界隔离的"代码宇宙"。这样，Agent就可以在里面随心所欲地读写文件、运行测试，而不会对你的真实计算机造成任何影响。
>
> **你的任务**: 指挥你的AI编程助手，设计一个名为 `BuggyProject` 的Python类。这个类，就是我们为Agent量身打造的、安全可控的"世界"。


### 指令剧本：与AI共建沙盒环境

我们将再次使用与AI协同的方式，一步步构建这个核心的环境类。

#### **第一步：定义项目的初始状态**

我们需要定义这个"代码宇宙"在创世之初的样子。它包含哪些文件？文件的内容是什么？

**【给AI的提示词】**

> 请帮我用Python编写一个名为 `BuggyProject` 的类，它将作为我们的沙盒环境。
>
> 首先，创建它的 `__init__` 方法。在这个方法里，我们要定义项目的初始文件结构。
>
> 请创建一个名为 `self.files` 的**字典**来模拟文件系统。
> *   **字典的键 (key)** 是**文件名** (字符串)。
> *   **字典的值 (value)** 是**文件内容** (字符串)。
>
> 现在，让我们在这个文件系统中放入两个文件：
> 1.  一个有bug的Python主程序 `main.py`。
> 2.  一个用于测试主程序的测试脚本 `test_main.py`。
>
> `main.py` 的内容是:
> ```python
> def add(a, b):
>     return a - b # 这是一个经典的、错误的减法实现
> ```
>
> `test_main.py` 的内容是:
> ```python
> from main import add
> 
> def test_add():
>     assert add(2, 3) == 5, "Test Failed: 2 + 3 should be 5"
> 
> # 为了能直接运行，我们加上这句
> if __name__ == "__main__":
>     test_add()
>     print("Tests passed!")
> ```
> 请把这些内容正确地设置到 `self.files` 字典中。


<details>
<summary>点击查看AI可能的输出</summary>

```python
class BuggyProject:
    def __init__(self):
        """
        初始化一个有bug的代码项目沙盒
        """
        self.files = {
            'main.py': 'def add(a, b):\n    return a - b # 这是一个经典的、错误的减法实现\n',
            'test_main.py': (
                'from main import add\n\n'
                'def test_add():\n'
                '    assert add(2, 3) == 5, "Test Failed: 2 + 3 should be 5"\n\n'
                'if __name__ == "__main__":\n'
                '    test_add()\n'
                '    print("Tests passed!")\n'
            )
        }

```
</details>



#### **第二步：赋予世界"运行"的能力**

我们的Agent需要一种方法来"运行测试"，以观察它所做的修改是否有效。这是Agent感知世界、获取反馈的核心途径。

**【给AI的提示词】**

> 接下来，请在 `BuggyProject` 类中添加一个名为 `run_tests` 的方法。这个方法是环境的核心，它模拟了运行测试脚本并返回结果的过程。
>
> 这个方法需要完成以下复杂但关键的逻辑：
>
> 1.  它需要安全地执行 `test_main.py` 中的代码。直接使用 `exec` 是危险的，但在这个受控的沙盒项目中，我们可以接受这个风险。
> 2.  为了让 `test_main.py` 能成功 `from main import add`，我们需要**动态地**将 `main.py` 的内容加载为一个Python模块。
> 3.  使用 `try...except` 语句来捕获测试过程中可能出现的任何异常（特别是 `AssertionError`，它代表测试失败）。
>
> **具体的实现细节如下：**
> *   引入 `importlib.util` 和 `sys` 库。
> *   从 `self.files` 中获取 `main.py` 和 `test_main.py` 的代码字符串。
> *   使用 `importlib.util.spec_from_loader` 和 `importlib.util.module_from_spec` 来动态创建一个名为 `main` 的模块。
> *   将 `main.py` 的代码 `exec` 到这个新创建的模块中。
> *   将这个模块添加到 `sys.modules` 中，这样 `test_main.py` 中的 `from main import add` 才能找到它。
> *   在一个 `try...except` 块中，`exec` `test_main.py` 的代码。
>     *   如果**没有异常**发生，说明测试通过！返回一个元组 `('success', 'All tests passed!')`。
>     *   如果捕获到**任何异常** ( `Exception as e` )，说明测试失败！返回一个元C组 `('failure', str(e))`，其中包含错误的类型和信息。
> *   最后，无论成功与否，都要记得从 `sys.modules` 中删除我们刚刚添加的 `main` 模块，以确保下次调用 `run_tests` 时环境是干净的。

*(这是一个比较复杂的指令，你可能需要和AI进行几次交互和微调才能得到完美的实现。这正是AI协同编程的真实体验！)*



> **学习者笔记**:
>
> `BuggyProject` 类就是我们为Agent定义的"**物理定律**"。它规定了这个世界里有什么（文件），以及这个世界是如何运转的（运行测试）。
>
> Agent的所有行动，都将通过与这个环境类交互来进行。它无法跳出这个沙盒，也无法违反我们定义的规则。
>
> *   **Agent的观察 (Observation)**: 就是调用 `env.run_tests()` 后返回的结果。`('failure', 'Test Failed...')` 就是Agent观察到的**当前状态**。
> *   **Agent的目标 (Goal)**: 就是通过一系列行动，最终让 `env.run_tests()` 返回 `('success', ...)`。
>
> 在下一节，我们将为Agent设计它的"四肢"——定义它能在这个世界中采取哪些具体的行动（工具）。 