# 12.1 Why: 将所有组件组装成一个可工作的系统

## 大厨的最后一步：从备菜到上菜

让我们再次回到厨房。

想象一下，一位世界顶级大厨，正在为一场国宴做准备。在过去的几个小时里，他完成了所有精细的**备菜工作**：
-   **食材A (文档)**: 最顶级的和牛肉，已经被精确地切割成了大小均匀的肉块（**文本分块**）。
-   **食材B (查询)**: 最新鲜的松露，也被小心地处理好，准备用于提味。
-   **调味料 (Embedding模型)**: 各种秘制的酱汁和香料已经按比例调配完毕。
-   **锅具 (向量数据库)**: 一口导热极快、温控精准的定制炒锅已经烧热，蓄势待发。

所有的准备工作都堪称完美。每一个独立的组件都达到了最优状态。

但是，如果这位大厨在完成备菜后，只是把这些准备好的食材堆在案板上，然后告诉食客们：“菜都准备好了，你们自己动手炒吧”，那会是怎样一种灾难性的场景？

**食客们（用户）需要的，不是一堆零散的、高质量的食材，而是一道被精心烹饪、整合在一起的、可以直接享用的美味佳肴。**

---

## 我们当前的处境

我们现在就和这位完成了备菜的大厨一样。我们已经拥有了：
-   高质量的**文档向量 (doc_embeddings)**
-   一个可以快速检索的**FAISS索引 (index)**
-   一个强大的**Embedding模型 (embedding_model)**
-   一种可以将任意问题转化为**查询向量**的能力

我们拥有所有必需的组件，但它们仍然是**分离的、手动的**。

在上一章的实践中，我们是手动地、一步步地调用代码来完成一次检索的。这对于学习和验证来说很好，但它不是一个**可工作的自动化系统**。

**一个真正的RAG系统，需要将所有这些步骤无缝地衔接起来，形成一个自动化的“烹饪流水线”。** 用户只需要输入他们的问题（点菜），系统就应该能自动地完成后续所有的工作——向量化、检索、整合、生成——最终将一份完美的答案（美味佳肴）呈现在用户面前。

将所有独立的组件，组装成一个可工作的、自动化的系统，这就是我们本章的核心任务。这个组装过程的“粘合剂”，就是如何与我们最终的“超级大厨”——大语言模型（LLM）——进行有效沟通。

在下一节，我们将开始设计这份沟通的核心蓝图：Prompt模板。 