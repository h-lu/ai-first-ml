# 13.5 Challenge: 将你的RAG实验代码重构为可交付的项目

恭喜你！你已经完成了RAG系统从构建、评估到优化的全过程。你拥有了经过实验验证的最佳参数，以及散落在各个`practice`中的代码片段。

然而，这些零散的Jupyter Notebook代码，还不是一个可以交付的"项目"。一个真正的AI项目，需要有清晰的结构、模块化的功能和可复用的代码。

现在，是时候进行我们作为AI工程师的最后一步——**代码重构 (Refactoring)** 了。

---

::: {.callout-warning title="项目重构挑战：与AI一起打造最终的RAG脚本"}

你的任务是：**指挥你的AI编程助手，将之前所有章节（10, 11, 12, 13）中关于RAG的代码片段，全部整合到一个单一的、结构清晰的、名为 `rag_project.py` 的Python脚本中。**

这个脚本应该是一个可以从头到尾独立运行，并产出最终评估结果的完整项目。

**指令剧本大纲:**

**第一步：定义最终脚本的结构**
> **👤 你的指令:**
> "你好AI助手。我需要将我分散的RAG代码整合成一个名为 `rag_project.py` 的单一脚本。请帮我设计这个脚本的结构。我希望它至少包含以下几个部分，请用函数或类的形式将它们组织起来：
> 1.  **全局配置**: 一个专门存放所有超参数的地方（如文件路径, chunk_size, top_k, reranker_top_n等）。
> 2.  **数据加载与预处理**: 一个函数，负责加载PDF文档并将其分块。
> 3.  **模型加载**: 一个函数，负责加载句嵌入模型和Reranker模型。
> 4.  **RAG核心流程**: 一个`RAGPipeline`类，它封装了构建FAISS索引、执行两阶段检索（Retriever+Reranker）和生成答案（或Prompt）的所有逻辑。
> 5.  **评估模块**: 一个函数或类，封装了加载评估数据集、调用Pipeline和计算评估分数的逻辑。
> 6.  **主执行入口**: 使用 `if __name__ == "__main__":` 来组织代码的执行流程，清晰地展示如何一步步调用上述模块，最终打印出不同参数组合的评估结果。"

**第二步：整合Reranker到Pipeline中**
> **👤 你的指令:**
> "很好。现在请帮我修改 `RAGPipeline` 类。我需要在其中加入Reranker的逻辑。
> -   它的 `answer` 方法现在应该接收一个 `reranker_model` 作为参数。
> -   方法内部的检索流程应该是两阶段的：
>     1.  首先，使用FAISS进行初步召回，获取一个较大的候选集（比如 `top_k=10`）。
>     2.  然后，使用 `reranker_model` 对这个候选集进行精排。reranker需要同时接收问题和每个候选文档块作为输入。
>     3.  最后，选择reranker打分最高的N个结果（比如 `reranker_top_n=3`）来构建最终的上下文。"

**第三步：填充所有模块并运行**
> **👤 你的指令:**
> "现在，请将我们之前所有章节的`practice`代码（PDF加载、分块、FAISS索引、评估集、评估函数等），全部填充到你为我设计的 `rag_project.py` 结构中。
> 请确保代码是完整、可执行的。最后，在 `if __name__ == "__main__":` 部分，请演示如何使用这个脚本来运行我们之前设计的参数优化实验，并打印出最终结果。"

**你的交付成果：**

通过与AI协同完成以上指令，你最终将获得一个 `rag_project.py` 文件。这份文件就是你RAG项目最终的、可交付的核心代码。它应该具备：
-   **模块化**: 功能被清晰地划分到不同的函数和类中。
-   **可配置**: 所有的重要参数都在文件的顶部集中管理，易于调整。
-   **可复现**: 任何人拿到你的脚本，只需要安装好依赖，就能完整地复现你的实验和结果。
-   **可扩展**: 基于这个清晰的结构，未来添加新的功能（如不同的模型、新的评估指标）会变得非常容易。

这个挑战，将完成你从"脚本小子"到"AI系统工程师"的最后一次蜕变。
:::
