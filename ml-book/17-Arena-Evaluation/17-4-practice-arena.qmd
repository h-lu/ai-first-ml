# 17.4 Practice: 搭建你的第一个AI竞技场

理论学习结束，现在让我们亲手搭建一个属于我们自己的"咖啡豆奇旅"AI竞技场。

在这个实践中，我们将使用`Gradio`库来创建一个Web界面，让我们可以方便地对SFT模型和DPO模型（或者你训练的任何两个模型）进行"背靠背"的盲测。

::: {.callout-caution title="资源提示"}
本次实践同样建议在具备GPU的云环境（如Google Colab, Kaggle）中完成，因为我们需要同时加载两个LLM模型，对显存有一定要求。
:::

### AI协同实践：一个完整的竞技场搭建指令剧本

在开始之前，请确保你已经将训练好的SFT模型和DPO模型（或PPO模型）保存在了你的工作目录中。

#### 第一幕：与AI一起设计竞技场的核心逻辑

::: {.callout-note title="第一步：请求AI编写竞技场后端代码" icon="fas fa-cogs"}

**你：** "你好，AI助手。我需要用Python和Gradio库为我的'咖啡豆奇旅'项目搭建一个AI竞技场。我需要评估两个我本地训练好的大语言模型。请帮我编写核心的后端代码，需要实现以下功能："

> "1.  **加载模型**: 编写一个函数，可以加载我指定路径的两个Hugging Face模型（SFT模型和DPO模型）和它们的Tokenizer。注意要将模型设置为评估模式。
> 2.  **定义对决函数**: 这是核心功能。请创建一个名为`battle(prompt)`的函数，它接收一个用户输入的问题（prompt）。函数内部需要完成：
>     a.  同时调用两个已经加载好的模型，根据prompt生成各自的回答。
>     b.  随机打乱两个回答的顺序，确保匿名性。比如，有时SFT的回答在左边，有时在右边。
>     c.  记录下这一次对决中，哪个模型被放在了左边，哪个在右边。我们可以用一个全局变量或者Gradio的状态（`gr.State`）来管理这个信息。
>     d.  返回两个匿名的回答，用于在Gradio界面上显示。
> 3.  **定义投票函数**: 创建一个名为`vote(winner)`的函数，它接收一个字符串，表示胜者（比如"模型A"或"模型B"）。函数内部需要：
>     a.  根据之前记录的对决状态，判断出这次投票究竟是投给了SFT模型还是DPO模型。
>     b.  将投票结果（如 `{'sft_model_wins': 1, 'dpo_model_wins': 0}`）记录下来。我们可以简单地打印出来，或者存入一个文件中。
>     c.  返回一个确认信息，比如"投票成功！"
> 4.  **初始化**: 将上述函数整合，并准备好所有必要的变量。"
:::

#### 第二幕：指挥AI构建Gradio前端界面

::: {.callout-note title="第二步：请求AI编写Gradio界面代码" icon="fas fa-desktop"}
**你：** "很好，后端逻辑已经清晰了。现在，请帮我用Gradio把这个竞技场的前端界面搭建起来。"

> "请创建一个`Gradio.Blocks`界面，包含以下元素：
> 1.  **标题**: 一个醒目的标题，例如"AI竞技场：咖啡豆奇旅巅峰对决"。
> 2.  **左右布局**: 使用`gr.Row()`将界面分为左右两部分。
>     *   **左边**: 显示"模型A"的回答，使用一个`gr.Textbox`，并设置`label="模型A"`和`interactive=False`。
>     *   **右边**: 显示"模型B"的回答，同样使用一个`gr.Textbox`，设置`label="模型B"`和`interactive=False`。
> 3.  **输入区域**: 在两个模型回答的下方，放置一个`gr.Textbox`，让用户可以输入问题（prompt），并设置`label="输入你的问题"`。
> 4.  **提交按钮**: 一个`gr.Button`，文字是"开始对决！"。点击后，应调用我们之前定义的`battle`函数。
> 5.  **投票按钮**:
>     *   在界面下方，用一个`gr.Row()`放置三个`gr.Button`。
>     *   **按钮1:** 文字是"模型A更好"。
>     *   **按钮2:** 文字是"模型B更好"。
>     *   **按钮3:** 文字是"平局/都差"。
>     *   点击这些按钮后，应调用我们之前定义的`vote`函数。
> 6.  **状态管理**: 不要忘记使用`gr.State()`来存储每次对决时模型的左右位置信息。
> 7.  **启动界面**: 最后，使用`demo.launch()`来运行这个Web应用。"
:::

---

### 第三幕：实现Elo评级，看到最终排名

仅仅收集投票是不够的，我们需要一个科学的算法来将"胜/负"数据转化为模型的"战斗力"分数。现在，让我们来完成这最后，也是最关键的一步。

::: {.callout-note title="第三步：请求AI编写Elo计算与展示代码" icon="fas fa-calculator"}
**你：** "竞技场已经可以运行了！现在我需要实现Elo评级系统来计算最终得分。请帮我在Gradio应用中增加这部分功能。"

> "1. **实现Elo计算函数**: 请编写一个名为`calculate_elo(rating1, rating2, result)`的Python函数。
>     *   `rating1`, `rating2`是两个模型当前的Elo分数。
>     *   `result`是比赛结果（1代表模型1赢，0.5代表平局，0代表模型1输）。
>     *   函数内部需要根据标准的Elo评级公式，计算出比赛后两个模型的新Elo分数。你可以使用一个固定的K因子（例如`K=32`）。
>     *   函数返回更新后的两个分数 `(new_rating1, new_rating2)`。
> 2. **更新投票逻辑**: 修改我们之前的`vote`函数。现在，当一次投票发生时，它不仅要记录胜负，还要：
>     a. 调用`calculate_elo`函数。
>     b. 更新两个模型全局的Elo分数。
> 3. **在界面上展示Elo分数**:
>     a. 在Gradio界面中，增加两个`gr.Number`组件，分别用于显示"模型A的Elo分数"和"模型B的Elo分数"。
>     b. 让`vote`函数在计算完新的Elo分数后，同时更新这两个`gr.Number`组件的显示值。
>     c. 这样，每次我们点击投票按钮，都能实时看到两个模型战斗力分数的变化！"
:::


现在，请打开你的AI编程环境，将这两幕的"指令剧本"交给你的AI助手。与它合作，一步步地将这个竞技场从概念变为一个可以交互的Web应用。

当应用成功运行，你亲手对两个模型的回答进行裁决时，你将真正理解现代LLM评估的核心方法论。享受作为"首席裁判"的乐趣吧！ 