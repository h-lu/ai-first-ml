# 18.3 What: LangGraph——用流程图构建AI Agent

::: {.callout-tip title="核心概念：LangGraph——用流程图构建AI Agent"}

**一句话定义：** LangGraph是一个将AI Agent的复杂思考和行动流程，转化为像"流程图"一样清晰、可控的节点和连接的编程框架。

---

**生动的类比："AI员工的SOP（标准作业流程）"**

想象一下，我们为新来的"AI员工"制定了一份处理"查询库存"任务的SOP流程图：

```mermaid
graph TD
    A["开始: 收到用户问题"] --> B{"需要使用工具吗?"};
    B -- "是" --> C["调用库存查询工具"];
    C --> D["获得库存信息"];
    D --> E{"思考: 现在该做什么?"};
    E --> F["生成最终答复"];
    B -- "否" --> F;
    F --> G["结束: 回复用户"];
```

LangGraph就是将这个SOP流程图"代码化"的工具。

*   **节点 (Nodes):** 流程图中的每一个**方框**和**菱形**都是一个"节点"。比如 `B{需要使用工具吗?}` 就是一个"思考节点"，它内部调用LLM来做决策；`C[调用库存查询工具]` 就是一个"工具节点"。
*   **边 (Edges):** 流程图中的**箭头**就是"边"。它们定义了任务的流向。其中，从`B`发出的两个不同箭头，就是一个"**条件边 (Conditional Edge)**"，它根据"思考节点"的结果，来决定流程的走向。
*   **状态 (State):** 我们可以想象有一个"任务篮子"，它从`A`节点开始，顺着箭头一路传递。每经过一个节点，都可能往篮子里放入新的东西。例如，`A`节点放入"用户问题"，`D`节点放入"库存信息"，`F`节点放入"最终答复"。这个"任务篮子"，就是LangGraph中的**全局状态**。

过去，我们构建Agent的代码可能像一长串的`if-else`语句，混乱且难以维护。而LangGraph通过这种基于图的构建方式，让我们能够像绘制SOP流程图一样，精确、清晰地设计Agent的行为逻辑。这对于理解和构建后面更复杂的"多Agent协作"流程至关重要。

你可以将它理解为一套用于将Agent的"思考-行动-观察"循环，升级为一套可视化、可管理的"标准作业流程"的强大工具。

::: 