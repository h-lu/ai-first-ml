# 18.4 Practice: 构建你的第一个工具Agent

现在，让我们把理论付诸实践，利用`LangGraph`亲手为"咖啡豆奇旅"构建第一个能使用工具的AI Agent。

**我们的目标：**
创建一个Agent，当用户提问"奇旅拼配还有库存吗？"时，它能：
1.  **思考：** 认识到需要查询库存。
2.  **行动：** 调用我们提供的`check_inventory`工具。
3.  **观察：** 获得库存数量。
4.  **再次思考并行动：** 将库存信息以自然语言的方式回复给用户。

::: {.callout-caution title="依赖安装"}
在开始之前，你需要安装一些新的库。你可以直接向你的AI助手提问："请给我一条pip命令，用于安装`langchain`, `langgraph`, `langchain-openai` 和 `langchain-community`"。（我们这里将使用OpenAI的模型作为Agent的"大脑"，因为它在工具调用方面经过了大量优化，效果更好。）
:::

### AI协同实践：一个完整的工具Agent搭建指令剧本

#### 第一幕：与AI一起定义Agent的"工具箱"

::: {.callout-note title="第一步：请求AI编写工具代码" icon="fas fa-tools"}

**你：** "你好AI助手，我准备用LangGraph为'咖啡豆奇旅'项目构建一个Agent。我需要先为这个Agent定义它能使用的工具。请帮我做以下几件事："
> "1.  **创建'工具箱'**: 创建一个名为`Toolbox`的Python类。
> "2.  **定义库存查询工具**: 在`Toolbox`类中，定义一个名为`check_inventory`的方法。
>     a.  这个方法应该接收一个参数 `bean_type: str`。
>     b.  为了模拟真实场景，方法内部的逻辑很简单：如果`bean_type`包含'奇旅拼配'，就返回一个随机生成的库存数量（比如30到100之间的一个整数）；否则，返回0。
>     c.  **最重要的一步**：为这个方法添加符合`langchain.tools.tool`装饰器的文档字符串（docstring）。这个文档字符串非常关键，因为Agent的'大脑'会通过阅读它来理解这个工具是做什么的、以及如何使用它。所以，文档字符串需要清晰地描述工具的功能。例如：'用于查询指定种类的咖啡豆的实时库存数量'。
> 3.  **实例化工具**: 最后，实例化这个`Toolbox`类，并创建一个包含`check_inventory`方法的工具列表。"

:::

#### 第二幕：指挥AI用LangGraph搭建"行动循环"

::: {.callout-note title="第二步：请求AI编写LangGraph流程代码" icon="fas fa-project-diagram"}
**你：** "工具已经准备好了。现在，请帮我用`LangGraph`将所有部分连接起来，构建一个完整的Agent行动流程。"

> "请帮我编写代码，实现以下步骤：
> 1.  **定义状态 (State)**: 定义一个Agent的状态图。这个状态需要能存储对话的`messages`。
> 2.  **设置大脑 (LLM)**: 初始化一个强大的LLM作为Agent的大脑。我们可以使用`ChatOpenAI`，并把我们之前创建的工具列表通过`.bind_tools()`方法'绑定'给它。
> 3.  **定义节点 (Nodes)**:
>     a.  **`call_model` 节点:** 这个节点负责调用LLM'大脑'。它接收当前的状态（主要是对话历史），调用LLM，然后将LLM的回答（可能包含工具调用请求）更新到状态中。
>     b.  **`call_tool` 节点:** 这个节点负责执行工具。它会检查'大脑'的最新回答，如果包含工具调用请求，就执行相应的工具函数，并将工具的输出结果（观察）更新到状态中。
> 4.  **定义边 (Edges)**: 这是流程控制的关键。我们需要定义一个`should_continue`函数来决定流程的走向。
>     a.  函数逻辑：检查'大脑'的最新回答。如果回答中包含工具调用，就返回`"continue"`，表示流程应走向`call_tool`节点。
>     b.  如果回答中不包含工具调用，就返回`"end"`，表示Agent已经思考完毕，流程结束。
> 5.  **构建图 (Graph)**:
>     a.  实例化一个`StateGraph`。
>     b.  添加我们定义的`call_model`和`call_tool`节点。
>     c.  设置`call_model`为图的入口点。
>     d.  添加从`call_tool`节点到`call_model`节点的普通边，形成循环。
>     e.  添加从`call_model`节点出发的条件边，根据`should_continue`的判断结果，决定是走向`call_tool`还是走向`END`（结束）。
>     f.  编译这个图，生成最终的可执行`app`。
> 6.  **运行Agent**: 调用`app.stream()`方法，传入用户的初始问题，并打印出每一步的思考、行动和观察，让我们能清晰地看到Agent的完整工作流程。"

:::

---

现在，终极挑战来了。与之前的章节不同，这次的"指令剧本"更加复杂和开放，它更像是一个"系统设计蓝图"。

请打开你的AI编程环境，将这份蓝图交给你的AI编程助手，与它一起，将这个Agent从概念一步步变为现实。

运行它，观察它，甚至尝试修改它——比如，给它添加一个`get_store_address`的新工具。欢迎来到Agentic时代，你现在已经是一个真正的"AI指挥家"了。