# 18.4 Practice: 构建你的第一个工具Agent

现在，让我们把理论付诸实践，利用`LangGraph`亲手为"咖啡豆奇旅"构建第一个能使用工具的AI Agent。

**我们的目标：**
创建一个Agent，当用户提问"奇旅拼配还有库存吗？"时，它能：
1.  **思考：** 认识到需要查询库存。
2.  **行动：** 调用我们提供的`check_inventory`工具。
3.  **观察：** 获得库存数量。
4.  **再次思考并行动：** 将库存信息以自然语言的方式回复给用户。

::: {.callout-caution title="依赖项安装：LangGraph与相关库" icon="fas fa-download"}
在开始之前，你需要安装一些新的库。请在你的终端或Jupyter Notebook中运行以下命令：

```bash
#| eval: false
pip install langchain langgraph langchain_openai langchain_community
```
我们这里将使用OpenAI的模型作为Agent的"大脑"，因为它在工具调用方面经过了大量优化，效果更好。你可能需要设置你的OpenAI API密钥。
:::

### AI协同实践：一个完整的工具Agent搭建指令剧本

#### 第一幕：与AI一起定义Agent的"工具箱"

::: {.callout-note title="第一步：请求AI编写工具代码" icon="fas fa-tools"}

**你：** "你好AI助手，我准备用LangGraph为'咖啡豆奇旅'项目构建一个Agent。我需要先为这个Agent定义它能使用的工具。请帮我做以下几件事："
> "1.  **创建'工具箱'**: 创建一个名为`Toolbox`的Python类。
> "2.  **定义库存查询工具**: 在`Toolbox`类中，定义一个名为`check_inventory`的方法。
>     a.  这个方法应该接收一个参数 `bean_type: str`。
>     b.  为了模拟真实场景，方法内部的逻辑很简单：如果`bean_type`包含'奇旅拼配'，就返回一个随机生成的库存数量（比如30到100之间的一个整数）；否则，返回0。
>     c.  **最重要的一步**：为这个方法添加符合`langchain.tools.tool`装饰器的文档字符串（docstring）。这个文档字符串非常关键，因为Agent的'大脑'会通过阅读它来理解这个工具是做什么的、以及如何使用它。所以，文档字符串需要清晰地描述工具的功能。例如：'用于查询指定种类的咖啡豆的实时库存数量'。
> 3.  **实例化工具**: 最后，实例化这个`Toolbox`类，并创建一个包含`check_inventory`方法的工具列表。"

:::

#### 第二幕：指挥AI用LangGraph搭建"行动循环"

::: {.callout-note title="第二步：请求AI编写LangGraph流程代码" icon="fas fa-project-diagram"}
**你：** "工具已经准备好了。现在，请帮我用`LangGraph`将所有部分连接起来，构建一个完整的Agent行动流程。"

> "请帮我编写代码，实现以下步骤：
> 1.  **定义状态 (State)**: 定义一个Agent的状态图。这个状态需要能存储对话的`messages`。
> 2.  **设置大脑 (LLM)**: 初始化一个强大的LLM作为Agent的大脑。我们可以使用`ChatOpenAI`，并把我们之前创建的工具列表通过`.bind_tools()`方法'绑定'给它。
> 3.  **定义节点 (Nodes)**:
>     a.  **`call_model` 节点:** 这个节点负责调用LLM'大脑'。它接收当前的状态（主要是对话历史），调用LLM，然后将LLM的回答（可能包含工具调用请求）更新到状态中。
>     b.  **`call_tool` 节点:** 这个节点负责执行工具。它会检查'大脑'的最新回答，如果包含工具调用请求，就执行相应的工具函数，并将工具的输出结果（观察）更新到状态中。
> 4.  **定义边 (Edges)**: 这是流程控制的关键。我们需要定义一个`should_continue`函数来决定流程的走向。
>     a.  函数逻辑：检查'大脑'的最新回答。如果回答中包含工具调用，就返回`"continue"`，表示流程应走向`call_tool`节点。
>     b.  如果回答中不包含工具调用，就返回`"end"`，表示Agent已经思考完毕，流程结束。
> 5.  **构建图 (Graph)**:
>     a.  实例化一个`StateGraph`。
>     b.  添加我们定义的`call_model`和`call_tool`节点。
>     c.  设置`call_model`为图的入口点。
>     d.  添加从`call_tool`节点到`call_model`节点的普通边，形成循环。
>     e.  添加从`call_model`节点出发的条件边，根据`should_continue`的判断结果，决定是走向`call_tool`还是走向`END`（结束）。
>     f.  编译这个图，生成最终的可执行`app`。
> 6.  **运行Agent**: 调用`app.stream()`方法，传入用户的初始问题，并打印出每一步的思考、行动和观察，让我们能清晰地看到Agent的完整工作流程。"

:::

---

现在，终极挑战来了。与之前的章节不同，这次的"指令剧本"更加复杂和开放，它更像是一个"系统设计蓝图"。

请打开你的AI编程环境，将这份蓝图交给你的AI编程助手，与它一起，将这个Agent从概念一步步变为现实。

运行它，观察它，甚至尝试修改它——比如，给它添加一个`get_store_address`的新工具。欢迎来到Agentic时代，你现在已经是一个真正的"AI指挥家"了。

## 本节小结

### 🎯 核心收获
- **工具即能力**: 你深刻地理解了AI Agent的能力来源于其绑定的"工具（Tools）"。通过为Agent编写函数并提供清晰的文档字符串，你学会了如何扩展Agent的行动边界。
- **LangGraph图思想**: 你掌握了使用`LangGraph`的核心思想——将Agent的行动流程抽象为"状态（State）"、"节点（Nodes）"和"边（Edges）"，并亲手搭建了一个包含条件判断的简单有向图。
- **ReAct循环实践**: 你不再只是理解ReAct（思考-行动-观察）的理论，而是通过`LangGraph`亲手实现了一个能完成该循环的、可以工作的AI Agent。

### 🤔 下一步的思考
- **单兵作战的局限**: 我们的"咖啡客服Agent"现在是一个"全能型员工"，它既要负责与用户沟通，又要自己去调用各种工具。如果任务变得更复杂，需要多个领域的专业知识（比如，既要查库存，又要处理复杂的物流问题，还要进行用户情感安抚），让一个Agent身兼数职可能会导致混乱和效率低下。
- **任务分解与协作**: 面对一个极其复杂的任务，人类社会的选择是"分工协作"。我们能否模仿这种模式，创建多个具有不同专业技能的AI Agent（比如"库存专员Agent"、"物流专家Agent"、"沟通专家Agent"），让它们像一个团队一样协同工作？

带着对"AI团队协作"的向往，准备好进入Agent世界的下一个阶段——多智能体协作了吗？